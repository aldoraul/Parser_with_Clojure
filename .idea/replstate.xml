<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1450074651404">{:repl-history {:ide [], :local [&quot;(def one-line (list))&quot; &quot;(with-open [rdr (reader \&quot;src/input2.txt\&quot;)]\n  (doseq [line (line-seq rdr)]\n    ( def one-line (conj one-line line))))&quot; &quot;(with-open [rdr (reader \&quot;src/input2.txt\&quot;)]\n  (doseq [line (line-seq rdr)]\n    ( def one-line (conj one-line line)\n      (loop [c (.read line)]\n        (if (not= c -1)\n          (do\n            (println \&quot;cool\&quot;)\n            (recur (.read line))) ))\n      \n      )))&quot; &quot;(def test \&quot;lifes hard\&quot;)&quot; &quot;(def test1 \&quot;lifes hard\&quot;)&quot; &quot;(loop [c .read test1]\n  (println c)\n  recur (.read c))&quot; &quot;(read-string (str \\( (slurp \&quot;src/input.txt\&quot;)))&quot; &quot;(def j 0)&quot; &quot;j&quot; &quot;(char? j)&quot; &quot;(int? j)&quot; &quot;(number? j)&quot; &quot;test1&quot; &quot;(string? test1)&quot; &quot;(char? (first test1))&quot; &quot;(char? (nth test1 5 ))&quot; &quot;(char 30)&quot; &quot;(char 66)&quot; &quot;(use 'clojure.java.io)\n(def one-line (list))\n(with-open [rdr (reader \&quot;input2.txt\&quot;)]\n  (doseq [line (line-seq rdr)]\n    ( def one-line (conj one-line line)))&quot; &quot;(use 'clojure.java.io)\n(def one-line (list))\n(with-open [rdr (reader \&quot;src/input.txt\&quot;)]\n  (doseq [line (line-seq rdr)]\n    ( def one-line (conj one-line line))\n    )) (println (char (nth one-line 2)))&quot; &quot;(use 'clojure.java.io)\n(def one-line (list))\n(with-open [rdr (reader \&quot;src/input.txt\&quot;)]\n  (doseq [line (line-seq rdr)]\n    ( def one-line (conj one-line line))))\n(dotimes [j (count one-line)]\n  (def expression (nth (reverse one-line) j) )\n(println (char? (nth expression 2))))&quot; &quot;(use 'clojure.java.io)\n(def one-line (list))\n(with-open [rdr (reader \&quot;src/input.txt\&quot;)]\n  (doseq [line (line-seq rdr)]\n    ( def one-line (conj one-line line))))\n(dotimes [j (count one-line)]\n  (def expression (nth (reverse one-line) j) )\n(println (char? (nth expression 0))))&quot; &quot;(use 'clojure.java.io)\n(def one-line (list))\n(with-open [rdr (reader \&quot;src/input.txt\&quot;)]\n  (doseq [line (line-seq rdr)]\n    ( def one-line (conj one-line line))))\n(dotimes [j (count one-line)]\n  (def expression (nth (reverse one-line) j) )\n(println (char (nth expression 0))))&quot; &quot;(char 97)&quot; &quot;(with-open [r (clojure.java.io/input-stream \&quot;src/input2.txt\&quot;)]\n  (loop [c (.read r)]\n    (if (not= c -1)\n      (do\n        (println (char? c))\n        (recur (.read r))))))&quot; &quot;(with-open [r (clojure.java.io/input-stream \&quot;src/input2.txt\&quot;)]\n  (loop [c (.read r)]\n    (if (not= c -1)\n      (do\n        (println (number? c))\n        (recur (.read r))))))&quot; &quot;(with-open [r (clojure.java.io/input-stream \&quot;src/input2.txt\&quot;)]\n  (loop [c (.read r)]\n    (if (not= c -1)\n      (do\n        (println c)\n        (recur (.read r))))))&quot; &quot;(def word \&quot;Good\&quot; \&quot;Bad\&quot;)&quot; &quot;(def word (list\&quot;Good\&quot; \&quot;Bad\&quot; ) )&quot; &quot;word&quot; &quot;(apply str word)&quot; &quot;(clojure.string/replace word #\&quot;\&quot;)&quot; &quot;(clojure.string/replace word #\&quot;Bad\&quot; \&quot;Good\&quot;)&quot; &quot;(seq word)&quot; &quot;(clojure.string/replace toke #\&quot;ID\&quot; \&quot;FACTOR\&quot;)&quot; &quot;(seq ( clojure.string/replace (apply str toke) #\&quot;ID\&quot; \&quot;FACTOR\&quot;) )&quot; &quot;(def toke (list( clojure.string/replace (apply str toke) #\&quot;ID\&quot; \&quot;FACTOR\&quot;) ) ) &quot; &quot;(def toke (seq (list( clojure.string/replace (apply str toke) #\&quot;id\&quot; \&quot;FACTOR\&quot;) ) )  )&quot; &quot;(def toke (list (seq( clojure.string/replace (apply str toke) #\&quot;id\&quot; \&quot;FACTOR\&quot;) ) )  )&quot; &quot;(def toke (list \&quot;id\&quot; \&quot;add\&quot; \&quot;id\&quot;))&quot; &quot;(def toke (list ( clojure.string/replace (apply str toke) #\&quot;id\&quot; \&quot;FACTOR\&quot;) ) ) &quot; &quot;(string? (first toke))&quot; &quot;(conj toke \&quot;ADD\&quot;)&quot; &quot;(concat toke \&quot;ADD\&quot;)&quot; &quot;(def toke (concat \&quot;ADD\&quot;))&quot; &quot;(list? toke)&quot; &quot;(char? toke)&quot; &quot;(seq? toke)&quot; &quot;(first toke )&quot; &quot;(char? (first toke))&quot; &quot;(list \&quot;one\&quot; \&quot;two\&quot;)&quot; &quot;(def one (list \&quot;one\&quot; \&quot;two\&quot;))&quot; &quot;(def two (list \&quot;three\&quot; \&quot;four\&quot;))&quot; &quot;two&quot; &quot;(concat one two)&quot; &quot;one&quot; &quot;(conj one two)&quot; &quot;(def final (concat one two))&quot; &quot;final&quot; &quot;(concat one)&quot; &quot;(def toke (list \&quot;ID\&quot; \&quot;ADD\&quot; \&quot;ID\&quot;))&quot; &quot;TOKE&quot; &quot;tok&quot; &quot;(def toke (replace toke #\&quot;ID \&quot; \&quot;FACTOR \&quot;))&quot; &quot;(def toke (clojre.string/replace toke #\&quot;ID \&quot; \&quot;FACTOR \&quot;))&quot; &quot;(string? toke)&quot; &quot;(replace toke #\&quot;ID \&quot; \&quot;FACTOR\&quot;)&quot; &quot;(clojure.string/replace toke #\&quot;ID \&quot; \&quot;FACTOR\&quot;)&quot; &quot;(def toke (clojure.string/replace toke #\&quot;ID \&quot; \&quot;FACTOR \&quot;))&quot; &quot;(seq toke)&quot; &quot;(def toke (list (clojure.string/split toke #\&quot; \&quot;)))&quot; &quot;(vector? toke)&quot; &quot;(vector? (first toke))&quot; &quot;(split (apply str toke) #\&quot;d\&quot;)&quot; &quot;(split toke #\&quot;d\&quot;)&quot; &quot;(clojure.string/split toke #\&quot;d\&quot;)&quot; &quot;\&quot;good\&quot;&quot; &quot;(if \&quot;goo\&quot;)&quot; &quot;(if (= true \&quot;good\&quot;))&quot; &quot;(if (= ( true \&quot;good\&quot;)))&quot; &quot;(if (= nil \&quot;good\&quot;)\n  \&quot;true\&quot;\n  \&quot;false\&quot;)&quot; &quot;(if (= true \&quot;good\&quot;)\n  \&quot;true\&quot;\n  \&quot;false\&quot;)&quot; &quot;(if (= 0 \&quot;good\&quot;)\n  \&quot;true\&quot;\n  \&quot;false\&quot;)&quot; &quot;(def toke [\&quot;id\&quot; \&quot;add\&quot; \&quot;id\&quot;])&quot; &quot;(def toke [\&quot;id \&quot; \&quot;add \&quot; \&quot;id \&quot;])&quot; &quot;(replace toke #\&quot;id \&quot; \&quot;factor \&quot;)&quot; &quot;(clojure.string/replace toke #\&quot;id \&quot; \&quot;factor \&quot;)&quot; &quot;(def toke (clojure.string/replace toke #\&quot;id \&quot; \&quot;factor \&quot;))&quot; &quot;(splilt toke #\&quot; \&quot;)&quot; &quot;(clojure.string/split toke #\&quot; \&quot;)&quot; &quot;(def toke  (clojure.string/split toke #\&quot; \&quot;) )&quot; &quot;(first toke)&quot; &quot;(apply str toke)&quot; &quot;(def toke (list \&quot;ID \&quot; \&quot;ADD \&quot; \&quot;ID \&quot;))&quot; &quot;(def (apply str toke))&quot; &quot;(def toke (apply str toke))&quot; &quot;(clojure.string/replace toke \&quot;#ID \&quot; \&quot;FACTOR \&quot;)&quot; &quot;(clojure.string/replace toke #\&quot;ID \&quot; \&quot;FACTOR \&quot;)&quot; &quot;(def toke (clojure.string/replace toke #\&quot;ID \&quot; \&quot;FACTOR \&quot;) ) &quot; &quot;(clojure.string/replace toke #\&quot;FACTOR ADD FACTOR \&quot; \&quot;TERM \&quot;)&quot; &quot;toke&quot;], :remote []}}</component>
</project>